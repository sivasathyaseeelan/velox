/**
 * Cluster configuration information.
 */
interface Cluster {
    nodes: object[];
}
/**
 * Record indicating what operations on ciphertexts are supported.
 */
interface Operations {
    store?: boolean;
    match?: boolean;
    sum?: boolean;
}
/**
 * Data structure for representing all categories of secret key.
 */
declare class SecretKey {
    material: object | number;
    cluster: Cluster;
    operations: Operations;
    protected constructor(cluster: Cluster, operations: Operations);
    /**
     * Generate a new secret key built according to what is specified in the supplied
     * cluster configuration and operation list.
     */
    static generate(cluster: Cluster, operations: Operations, seed?: Uint8Array | Buffer | string | null): Promise<SecretKey>;
    /**
     * Return a JSON-compatible object representation of the key instance.
     */
    dump(): object;
    /**
     * Create an instance from its JSON-compatible object representation.
     */
    static load(object: object): SecretKey;
}
/**
 * Data structure for representing all categories of cluster key.
 */
declare class ClusterKey extends SecretKey {
    /**
     * Generate a new cluster key built according to what is specified in the supplied
     * cluster configuration and operation list.
     */
    static generate(cluster: Cluster, operations: Operations): Promise<ClusterKey>;
    /**
     * Create an instance from its JSON-compatible object representation.
     */
    static load(object: object): ClusterKey;
}
/**
 * Data structure for representing all categories of public key.
 */
declare class PublicKey {
    material: object;
    cluster: Cluster;
    operations: Operations;
    private constructor();
    /**
     * Generate a new public key corresponding to the supplied secret key
     * according to any information contained therein.
     */
    static generate(secretKey: SecretKey): Promise<PublicKey>;
    /**
     * Return a JSON-compatible object representation of the key instance.
     */
    dump(): object;
    /**
     * Create an instance from its JSON-compatible object representation.
     */
    static load(object: object): PublicKey;
}
/**
 * Return the ciphertext obtained by encrypting the supplied plaintext
 * using the supplied key.
 */
declare function encrypt(key: PublicKey | SecretKey, plaintext: number | bigint | string): Promise<string | string[] | number[]>;
/**
 * Return the plaintext obtained by decrypting the supplied ciphertext
 * using the supplied secret key.
 */
declare function decrypt(secretKey: SecretKey, ciphertext: string | string[] | number[]): Promise<bigint | string>;
/**
 * Convert an object that may contain ciphertexts intended for multi-node
 * clusters into secret shares of that object. Shallow copies are created
 * whenever possible.
 */
declare function allot(document: object): object[];
/**
 * Convert an array of compatible secret share objects into a single object
 * that deduplicates matching plaintext leaf values and recombines matching
 * secret share leaf values.
 */
declare function unify(secretKey: SecretKey, documents: object[], ignore?: string[]): Promise<object | Array<object>>;
/**
 * Export library wrapper.
 */
declare const nilql: {
    readonly SecretKey: typeof SecretKey;
    readonly ClusterKey: typeof ClusterKey;
    readonly PublicKey: typeof PublicKey;
    readonly encrypt: typeof encrypt;
    readonly decrypt: typeof decrypt;
    readonly allot: typeof allot;
    readonly unify: typeof unify;
};

export { nilql };
